[{"title":"干饭人の大危機","path":"/2020/12/10/干饭人の大危機/","content":"1、危機起因今天是12月10号，距离疫情发生不知道过了多少天反正总之就是很多天都它喵快一年了的一天。 公司自从复工后依然在执行午饭需要提前预定的制度，虽说是为了大家的健康着想，但是每天都要等到晚上十二点然后打开app订餐，对于我这种一天至少需要睡八-九小时的生物来说简直是一种折磨。 因此我决定开始那个计划！（主要是原来计划过然后忘了执行了···）。 2、大致思路 使用抓包工具对手机app进行抓包，获取订餐对应的API接口 编写一个定时任务进行伪造订餐请求，并在指定时间发送 将项目打包扔到服务器上运行 3、計畫開始！① 抓包！我使用的抓包工具就是比较知名的Fiddler 直接搜索引擎搜就完事了，或者直接点击这里的官网链接 然后下载安装，安装一直下一步就可以 Fiddler主要是一个抓Web的工具，但是也可以抓外部设备的访问请求，只不过需要设置代理 关闭电脑的防火墙 Mac的比较简单：打开系统便好设置 –&gt;安全与隐私–&gt;防火墙 然后关闭就行了 Windows的我也忘了在哪了，反正找不到就去搜一下 打开Fiddler找到右上角设置 依次是 允许权限、捕获HTTPS请求、忽略请求错误 然后就是设置代理 记住这个端口号，默认是8866 选项依次是：启动时开启代理、允许外部设备访问 设置完成之后点save然后重启Fiddler，记得重启，不然设置不会生效 确保手机和电脑在同一个局域网下 然后配置手机的代理 step 1step 2step 3 服务器地址为你的电脑的IP地址，端口号就是刚才在Fiddler中设置的端口号了 Mac可以直接打开网络偏好设置查看 windos可以cmd输入 1ipconfig 正式开始抓包 这时候如果你刷新网页的话，Fiddler中会出现大量请求，所以需要关掉可能会出现网络请求的程序。然后打开手机app 这时候就需要你仔细寻找了，发现了公司的服务器IP请求，然后看一下请求相应的数据。 没错，就是这个了。话说食堂的糖醋里脊真的不怎么样 然后因为请求确实太多，添加一个过滤条件过滤一下 直接使用请求头中Host作为条件即可 现在就获取到了需要的请求接口和Header以及负载的Body数据 ② 编写程序由于这个程序写出来就只为了给我自己订餐，所以在编写过程中很多地方都是硬编码 发送请求我使用的是hutool工具包中封装好的HttpRequest类 具体代码我就不贴了，因为涉及公司的IP地址，及app的接口等 不过定时任务的代码可以贴一下 1234567891011121314151617181920212223242526272829303132333435@RestController@Slf4jpublic class OrderController &#123; @Autowired HttpRequestService service; @Autowired private ThreadPoolTaskScheduler threadPoolTaskScheduler; private ScheduledFuture&lt;?&gt; future; @Bean public ThreadPoolTaskScheduler threadPoolTaskScheduler() &#123; return new ThreadPoolTaskScheduler(); &#125; @Value(&quot;$&#123;cron.prod&#125;&quot;) private String cron; @GetMapping(&quot;/start&quot;) public String start() &#123; future = threadPoolTaskScheduler.schedule(new MyRunnable(service), new CronTrigger(cron)); return &quot;startTask&quot;; &#125; @GetMapping(&quot;/stop&quot;) public String stop() &#123; if (future != null) &#123; future.cancel(true); &#125; return &quot;stopTask&quot;; &#125;&#125; 主要是写了两个接口用来控制定时任务的开启和关闭 然后在本机调试 ③ 服务器运行想要实现在十二点订餐肯定不能只让程序运行在本机电脑上，否则你的电脑需要整晚开机，或者你可以设置定时关机。但这也太麻烦了，而且订个餐还需要占用办公电脑，这显然是不现实的。所以需要把jar包扔到服务器上运行 因为创建的项目是SpringBoot项目，因此可以直接打Jar运行，方便很多 你可以传统的在本地把Jar包打包好，然后上传服务器，Java -Jar 运行 不过我选择第二种方式，直接使用一个idea上阿里的插件一键部署 从上到下依次是 文件获取方式，也就是你的项目最终编译完成后的文件： 你可以选择maven构建后生成的文件，这时你需要输入maven具体的构建命令，一般就是clean install 手动指定上传的文件 Gradle打包，当前是个maven项目，因此不可使用 选择你要上传的服务器实例 上传到哪个路径下 上传完成后需要执行的命令 关于这个需要说一下，因为我的项目是个jar包，直接使用Java -jar运行的话，直接关掉命令行面板就会停止运行，所以需要设置后台运行的命令 1nohup java -jar xxx.jar &gt; log.txt &amp; 到这还需要你进入阿里云的控制台，找到你的服务器实例，打开这个项目所在端口的访问权限 最后，访问你的服务器打开定时任务就完成了 4、作戰結束干饭人大获全胜！🎉🎉🎉🎉","tags":["抓包","请求伪装"],"categories":["SpringBoot"]},{"title":"使用Glide在Android应用中加载网络图片","path":"/2020/05/16/使用Glide在Android应用中加载网络图片/","content":"代码由于宽度比较小被换行了，看着很不整齐，其实很整齐，注释写得比较详细，比较多不容易阅读，可以先复制到ide或者Vscode里阅读 布局文件里只有一个imageview 动画资源文件可以不需要 Json文件放置的目录为 &#x2F;rememberWords&#x2F;internetPic&#x2F;src&#x2F;main&#x2F;assets&#x2F;test.json gradle的设置 注意选择自己Module的build.gradle文件 123456789101112//这里是需要添加的代码段，注意是在dependencies添加，不是再创建一个dependenciesdependencies &#123; implementation &#x27;com.github.bumptech.glide:glide:4.11.0&#x27; annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.11.0&#x27; compile &#x27;org.apache.httpcomponents:httpcore:4.4.4&#x27;&#125;//这里是需要直接添加在build.gradle文件中的repositories &#123; mavenCentral() google()&#125; MainActivity类实现主要功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.example.internetpic;import androidx.appcompat.app.AppCompatActivity;import android.graphics.drawable.Drawable;import android.os.Bundle;import android.view.MotionEvent;import android.view.View;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.widget.ImageView;import android.widget.Toast;import com.bumptech.glide.Glide;import com.bumptech.glide.RequestBuilder;import com.bumptech.glide.request.RequestOptions;import org.apache.http.util.EncodingUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Random;import javax.xml.transform.Transformer;public class MainActivity extends AppCompatActivity &#123; private ArrayList&lt;String&gt; arrPicPath = new ArrayList&lt;&gt;();//list存储图片URL private String Str_json;//全局变量存储json文件转换来的字符串 private int index = 0;//List下标（索引） private float touchDownX,touchUpX;//按下、抬起时的X坐标 ImageView imageView;//这个就不要写了吧 Animation animation;//存储动画资源 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = findViewById(R.id.imageview);//ID获取image view animation = AnimationUtils.loadAnimation(this,R.anim.anim_alpha_in);//加载本地动画资源文件 imageView.setAnimation(animation);//给image view设置动画 doReadJson();//自定义方法，从本地读取Json文件 doParseJson();//自定义方法，解析Json文件 RequestOptions options = new RequestOptions();//实例化一个option对象，并设置属性 options.centerCrop()//设置居中 .transform(new dictionaryTransform())//调用transform，实例化dictionaryTransform类调用自定义方法BitmapMosaic实现打码 .placeholder(R.drawable.img_load)//设置加载时显示的图片（占位） .error(R.drawable.img_load)//失败时显示的图片 .fallback(R.drawable.img_load);//反馈图片 final RequestBuilder&lt;Drawable&gt; requestBuilder =//定义一个RequestBuilder&lt;Drawable&gt;对象 Glide.with(this)//实例化一个Glide对象 .asDrawable()//设置对象类型为Drawable .apply(options);//应用options的设置 final RequestBuilder&lt;Drawable&gt; requestBuilderwithout =//同上，但是这个对象不设置option，用以设置无打码的图片 Glide.with(this) //其实严谨点应该设置两个option .asDrawable(); requestBuilder.clone()//清除 .load(arrPicPath.get(index))//根据索引找到list中对应URL，load方法加载网络图片 .into(imageView);//把图片放进image view，注意：此时使用的是设置过option的对象，即打码的图片// Glide.with(this).load(&quot;https://www.baidu.com/img/bd_logo1.png&quot;).into(imageView); imageView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123;//为image view设置触摸监听事件 if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;//event.getAction()获取当前事件，利用常量判断该事件是否为按下事件 touchDownX = event.getX();//获取按下时的坐标，并存储 return false;//返回false表示按下事件没有被处理完，下面的监听事件才可以继续处理该按下事件 &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123;//同上，判断是否抬起 touchUpX = event.getX();//获取抬起时坐标，储存 if (touchUpX - touchDownX &gt; 50) &#123;//判断按下抬起坐标间隔，并定义为一次从左到右滑动 Random r = new Random();//定义并实例化一个随机数对象 index = index == 0 ? arrPicPath.size() - 1 : r.nextInt(arrPicPath.size());//三位运算符，判断index是否等于0， // 若等于0则使index等于List的最后一个元素，若不等于0则使index等于生成的（0-list元素个数）一个随机数 //其实这一步逻辑上有错，因为一开始设置为有顺序的循环显示图片，所以需要判断左右滑动和List的下标防止越界 //改为随机后可直接删除左右滑动判断，和下标判断，直接随机数设置下标即可 requestBuilder.clone()//清除 .load(arrPicPath.get(index))//加载随机后的图片 .into(imageView);//设置进image view，同上，注意：此时依然设置的是打码图片 &#125; else if (touchDownX - touchUpX &gt; 50) &#123;//同上，不再赘述 Random r = new Random(); index = index == arrPicPath.size() - 1 ? 0 : r.nextInt(arrPicPath.size()); requestBuilder.clone() .load(arrPicPath.get(index)) .into(imageView); &#125; &#125; return false;//注意！返回false表示抬起事件没有处理完，由于我下面的监听使用的是长按事件，所以上面两个是false还是true没有影响 //如果想使用单击事件（onClick）则按下事件要返回false &#125; &#125;);// Glide.with(this)// .load(R.drawable.img01)// .apply(options)// .into(imageView); imageView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123;//给image view设置长按事件 requestBuilderwithout.clone()//注意：此时使用的是没有设置option的对象，即加载的图片是无码的 .load(arrPicPath.get(index)) .into(imageView); return true;//返回true，表示长按事件处理完毕 &#125; &#125;); &#125; /*读取Json*/ public void doReadJson()&#123; try &#123; InputStream is = getResources().getAssets().open(&quot;test.json&quot;);//根据文件名打开json文件，并存入输入流对象 int length = is.available();//获取输入流字节长度 byte[] buffer = new byte[length];//定义一个字节数组作为缓冲，长度为输入流的长度 is.read(buffer);//将输入流中数据放进缓冲字节数组中 Str_json = EncodingUtils.getString(buffer,&quot;utf-8&quot;);//把字节数组中的数据放入字符串中，这样就把json文件读取成了字符串 is.close();//切记，不要忘记关闭流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /*解析Json*/ public void doParseJson() &#123; if (Str_json == null) &#123;// 判断用户是否读取了Json文件 Toast.makeText(this, &quot;请先读取Json文件！&quot;, Toast.LENGTH_SHORT).show();//没有就弹出提示 &#125; else &#123; try &#123; JSONArray jsonArray = new JSONArray(Str_json);// 基于Str_json字符串创建Json对象数组 for (int i = 0; i &lt; jsonArray.length(); i++) &#123;// 遍历Json数组 JSONObject jsonObject = jsonArray.getJSONObject(i);// 通过下标获取json数组元素——Json对象 // 对Json对象按键取值，其实我只需要image的网址就行了，也不需要组成对象2333，但是这只是个demo，组成对象是为了供后面使用 int id = jsonObject.getInt(&quot;id&quot;); String word = jsonObject.getString(&quot;word&quot;); String explain = jsonObject.getString(&quot;explain&quot;); String sound = jsonObject.getString(&quot;sound&quot;); String image = &quot;https://fox.ftqq.com/&quot;+jsonObject.getString(&quot;image&quot;); Word wordObject = new Word(id, word, explain, sound, image);// 组成Word对象 arrPicPath.add(wordObject.getImage());//获取对象中的image的值，并添加到List中 &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; dictionaryTransform类用来实现打码功能其中的打码方法是在一篇文章里看到的，找不到来源了，原作者如果看到的话可以加上您的链接嗷 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.example.internetpic;import android.graphics.Bitmap;import android.graphics.Color;import androidx.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;public class dictionaryTransform extends BitmapTransformation &#123; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return BitmapMosaic(toTransform,40); &#125; @Override public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) &#123; &#125; public static Bitmap BitmapMosaic(Bitmap bitmap, int BLOCK_SIZE) &#123; if (bitmap == null || bitmap.getWidth() == 0 || bitmap.getHeight() == 0 || bitmap.isRecycled()) &#123; return null; &#125; int mBitmapWidth = bitmap.getWidth(); int mBitmapHeight = bitmap.getHeight(); Bitmap mBitmap = Bitmap.createBitmap(mBitmapWidth, mBitmapHeight, Bitmap.Config.ARGB_8888);//创建画布 int row = mBitmapWidth / BLOCK_SIZE;// 获得列的切线 int col = mBitmapHeight / BLOCK_SIZE;// 获得行的切线 int[] block = new int[BLOCK_SIZE * BLOCK_SIZE]; for (int i = 0; i &lt;=row; i++) &#123; for (int j =0; j &lt;= col; j++) &#123; int length = block.length; int flag = 0;// 是否到边界标志 if (i == row &amp;&amp; j != col) &#123; length = (mBitmapWidth - i * BLOCK_SIZE) * BLOCK_SIZE; if (length == 0) &#123; break;// 边界外已经没有像素 &#125; bitmap.getPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, mBitmapWidth - i * BLOCK_SIZE, BLOCK_SIZE); flag = 1; &#125; else if (i != row &amp;&amp; j == col) &#123; length = (mBitmapHeight - j * BLOCK_SIZE) * BLOCK_SIZE; if (length == 0) &#123; break;// 边界外已经没有像素 &#125; bitmap.getPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, BLOCK_SIZE, mBitmapHeight - j * BLOCK_SIZE); flag = 2; &#125; else if (i == row &amp;&amp; j == col) &#123; length = (mBitmapWidth - i * BLOCK_SIZE) * (mBitmapHeight - j * BLOCK_SIZE); if (length == 0) &#123; break;// 边界外已经没有像素 &#125; bitmap.getPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, mBitmapWidth - i * BLOCK_SIZE, mBitmapHeight - j * BLOCK_SIZE); flag = 3; &#125; else &#123; bitmap.getPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);//取出像素数组 &#125; int r = 0, g = 0, b = 0, a = 0; for (int k = 0; k &lt; length; k++) &#123; r += Color.red(block[k]); g += Color.green(block[k]); b += Color.blue(block[k]); a += Color.alpha(block[k]); &#125; int color = Color.argb(a / length, r / length, g / length, b / length);//求块内所有颜色的平均值 for (int k = 0; k &lt; length; k++) &#123; block[k] = color; &#125; if (flag == 1) &#123; mBitmap.setPixels(block, 0, mBitmapWidth - i * BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, mBitmapWidth - i * BLOCK_SIZE, BLOCK_SIZE); &#125; else if (flag == 2) &#123; mBitmap.setPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, BLOCK_SIZE, mBitmapHeight - j * BLOCK_SIZE); &#125; else if (flag == 3) &#123; mBitmap.setPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, mBitmapWidth - i * BLOCK_SIZE, mBitmapHeight - j * BLOCK_SIZE); &#125; else &#123; mBitmap.setPixels(block, 0, BLOCK_SIZE, i * BLOCK_SIZE, j * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); &#125; &#125; &#125; //并没有回收传进来的bitmap 原因是JAVA传值默认是引用,如果回收了之后,其他地方用到bitmap的位置可能报NULL指针异常,请根据实际情况决定是否回收. return mBitmap; &#125;&#125;","tags":["网络图片加载"],"categories":["Android"]},{"path":"/about/index.html","content":"时间线友链关于 关于 正在施工中 ···"},{"path":"/bookmark/index.html","content":"备忘收藏 收藏夹 正在施工中 ···"},{"path":"/friends/index.html","content":"时间线友链关于 友链 正在施工中 ···"},{"path":"/notes/index.html","content":"备忘收藏 备忘录 正在施工中 ···"},{"path":"/timeline/index.html","content":"时间线友链关于 时间线 正在施工中 ···"},{"title":"分类A的一篇文章","path":"/notes/class_a/index.html","content":"正在施工中 ···"},{"title":"分类B的一篇文章","path":"/notes/class_b/index.html","content":"正在施工中 ···"}]